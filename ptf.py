#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Name:       File comparison utility
# Author:     Nathan Bird
# Website:    https://github.com/milbot/pentest-framework
# Date:       23 July 2014
# Licence:    GNU GENERAL PUBLIC LICENSE v2
#
# This framework assumes that the user already knows, or has a list of "live
# hosts". If you do not, please run discover.py first to determine possible
# targets for use against this framework.
#

import sys, os, datetime, difflib, subprocess, optparse, re, urllib2
from os.path import expanduser

VERSION = "1.0"
USERHOME = expanduser("~")
PROG="ptf.py"
LINE=" ---------------------------------------------------------------------------------------\n"

#-----------------------------------------------------------------------------
# Compiled Regular Expressions
#-----------------------------------------------------------------------------
report_re = re.compile('Nmap scan report for (.*)')
gnmap_re = re.compile('Host: (.*)Ports:')
version_re = re.compile('# Nmap 6.25 scan initiated')
host_re = re.compile('Host: (.*) .*Ports:')
ports_re = re.compile('Ports: (.*)\sIgnored State:')
os_re = re.compile('OS: (.*)\sSeq Index:')

def run_command(cmd):
    p = subprocess.Popen(cmd.split(), stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    
    resp = p.stdout.read()
    warnings = p.stderr.read()
    p.stdout.close()
    p.stderr.close()
    
    # Return any warnings and the raw response.
    return warnings, resp

def print_warnings(warnings):
    for w in warnings.split('\n'):
        if w == '':
            continue
        print '[-] {0}'.format(w)
        if w == 'QUITTING!':
            sys.exit()

def red(string):
	return "\033[1;31m"+string+"\033[1;m"

def green(string):
	return "\033[92m"+string+"\033[1;m"

def yellow(string):
	return "\033[93m"+string+"\033[1;m"

def mutedgrey(string):
	return "\033[1;30m"+string+"\033[1;m"

def bold(string):
	return "\033[1m"+string+"\033[1;m"

def banner():
	print
	print ""+LINE
	print red("  ___            _____       _   _             ___                                  _   ")
	print red(" | _ \___ _ _   |_   _|__ __| |_(_)_ _  __ _  | __| _ __ _ _ __  _____ __ _____ _ _| |__")
	print red(" |  _/ -_) ' \    | |/ -_|_-<  _| | ' \/ _` | | _| '_/ _` | '  \/ -_) V  V / _ \ '_| / /")
	print red(" |_| \___|_||_|   |_|\___/__/\__|_|_||_\__, | |_||_| \__,_|_|_|_\___|\_/\_/\___/_| |_\_\\")
	print red("                                       |___/                                            ")
	print
	print mutedgrey(" Author: Nathan Bird (milbot)")
	print mutedgrey(" Website: https://github.com/milbot/pentest-framework")
	print mutedgrey(" Version: "+VERSION+"\n")

def printconfig(source,target,path):
	print mutedgrey(" PTF is configured to run as follows:\n")
	print mutedgrey(" Source IP Address: "+source)
	print mutedgrey(" Target(s):         "+target)
	print mutedgrey(" Path for output:   "+path)
	print

def checkversion():
	try:
		response = urllib2.urlopen("http://github.com", timeout = 1)

		commits_behind = subprocess.check_output("git rev-list HEAD...origin/master --count", shell=True)
		if int(commits_behind) != 0:
			print " You are behind the master version.\n Please update to ensure you are running the latest version of this framework.\n Update by using the -u flag when running "+PROG+".\n\n E.g. ./ptf.py [options] -s source -t target\n"

	except urllib2.URLError as err: pass

def cleanup(path, scanname):
	# Run cleanup is selected by user
	print bold(" [*] Cleaning up previous scan results ({0})....\n".format(os.path.join(path,scanname)))
	run_command("rm -rf {0}".format(os.path.join(path,scanname)))
	
	return True

def runupdate():
	try:
		response = urllib2.urlopen("http://github.com", timeout = 1)
		print "\nUpdating ExploitDB...."
		subprocess.Popen("apt-get install exploitdb -y", shell=True)
		print "\nUpdate complete. Please re-run the framework to use the latest version.\n"
		sys.exit()

	except urllib2.URLError as err: pass

def hostdiscover(options, FULLPATH):
	# Create paths if they do not exists
	if not os.path.exists(FULLPATH):
		os.makedirs(FULLPATH)

	# Confirm hosts are alive
	if options.target:
		print bold(" [*] Running host discovery against single target {0}").format(options.target)
		cmd = "nmap -sn -T4 --stats-every 10s {0} -oA {1}/hosts_alive".format(options.target, FULLPATH)
		warnings, resp = run_command(cmd)
		print_warnings(warnings)
	else:
		print bold(" [*] Running host discovery against target input file {0}").format(options.targetfile)
		if options.exclude:
			print "   [-] Excluding host {0}".format(options.exclude)
			cmd = "nmap -sn -T4 --stats-every 10s -iL {0} --exclude {1} -oA {2}/hosts_alive".format(options.targetfile, options.exclude, FULLPATH)
			warnings, resp = run_command(cmd)
			print_warnings(warnings)
		elif options.excludefile:
			cmd = "nmap -sn -T4 --stats-every 10s -iL {0} --excludefile {1} -oA {2}/hosts_alive".format(options.targetfile, options.exclude, FULLPATH)
			warnings, resp = run_command(cmd)
			print_warnings(warnings)
		else:
			cmd = "nmap -sn -T4 --stats-every 10s -iL {0} -oA {1}/hosts_alive".format(options.targetfile, FULLPATH)
			warnings, resp = run_command(cmd)
		print_warnings(warnings)
	
	input = os.path.join(FULLPATH,"hosts_alive.gnmap")
	output = os.path.join(FULLPATH,"hosts_alive.txt")
	cmd = "grep Up {0} | cut -d' ' -f2 > {1}".format(input, output)
	if os.system(cmd) == os.EX_OK:
		print " Please review file {0} to confirm the hosts that have been detected by the discovery scan.\n".format(os.path.join(FULLPATH, "hosts_alive.txt"))
		print " The framework will now continuing executing using 'hosts_alive.txt' the target input file....\n\n"
	
	return

def dnsdiscover(options, FULLPATH):
    return

def serviceenumeration(options, FULLPATH):
	# Run unicornscan to identify open ports, and then NMAP for further scanning
	# This combo is done to speed the process up as unicornscan will scan faster
	# then NMAP alone
	
	# Create paths if they do not exists
	if not os.path.exists(os.path.join(FULLPATH, "unicornscans")):
		os.makedirs(os.path.join(FULLPATH, "unicornscans"))
	
	if not os.path.exists(os.path.join(FULLPATH, "nmapscans")):
		os.makedirs(os.path.join(FULLPATH, "nmapscans"))
	
	# Start scans
	print bold(" [*] Running Unicornscan and NMAP to identify all open ports and services")
	if options.target:
		target = options.target

		# TCP
		if options.ports == None:
			print "   [+] Scanning TCP ports: 1-65535"
			cmd = "unicornscan -msf -Iv {0} -p 1-65535 -l {1}".format(target, os.path.join(os.path.join(FULLPATH,"unicornscans"), target+"-tcp.txt"))
			warnings, resp = run_command(cmd)
			print_warnings(warnings)
		else:
			print "   [+] Scanning TCP ports: {0}".format(options.ports)
			cmd = "unicornscan -msf -Iv {0} -p {1} -l {2}".format(target, options.ports, os.path.join(os.path.join(FULLPATH,"unicornscans"), target+"-tcp.txt"))
			warnings, resp = run_command(cmd)
			print_warnings(warnings)

		cmd = "cat {0} | grep open | egrep -v '\[' | cut -d':' -f2 | cut -d' ' -f1 | tr '\n' ',' | rev | cut -b 2- | rev > {1}".format(os.path.join(os.path.join(FULLPATH,"unicornscans"), options.target+"-tcp.txt"),os.path.join(os.path.join(FULLPATH,"unicornscans"), "temp-tcp.txt"))
		os.system(cmd)
		tcp_port_file = file(os.path.join(os.path.join(FULLPATH,"unicornscans"), "temp-tcp.txt"))
		if os.path.isfile(os.path.join(os.path.join(FULLPATH,"unicornscans"), "temp-tcp.txt")) and os.path.getsize(os.path.join(os.path.join(FULLPATH,"unicornscans"), "temp-tcp.txt")) > 0:
			for tcp_ports in tcp_port_file:
				if tcp_ports:
					print "   [+] Identified TCP: {0}".format(tcp_ports)
				else:
					print "   [+] No TCP ports identified"
		
			print "   [+] Running TCP NMAP scans"
			cmd = "nmap -sS -sV -oA {0} -p {1} {2}".format(os.path.join(os.path.join(FULLPATH,"nmapscans"), target+"-tcp"),tcp_ports,target)
			warnings, resp = run_command(cmd)
			print_warnings(warnings)

		# UDP
		if options.ports == None:
			print "   [+] Scanning UDP ports: 1-65535"
			cmd = "unicornscan -mU -Iv {0} -p 1-65535 -l {1}".format(options.target, os.path.join(os.path.join(FULLPATH,"unicornscans"), options.target+"-udp.txt"))
			warnings, resp = run_command(cmd)
			print_warnings(warnings)
		else:		
			print "   [+] Scanning UDP ports: {0}".format(options.ports)
			cmd = "unicornscan -mU -Iv {0} -p {1} -l {2}".format(options.target, options.ports, os.path.join(os.path.join(FULLPATH,"unicornscans"), options.target+"-udp.txt"))
			warnings, resp = run_command(cmd)
			print_warnings(warnings)

		cmd = "cat {0} | grep open | egrep -v '\[' | cut -d':' -f2 | cut -d' ' -f1 | tr '\n' ',' | rev | cut -b 2- | rev > {1}".format(os.path.join(os.path.join(FULLPATH,"unicornscans"), options.target+"-udp.txt"), os.path.join(os.path.join(FULLPATH,"unicornscans"), "temp-udp.txt"))
		os.system(cmd)
		udp_port_file = file(os.path.join(os.path.join(FULLPATH,"unicornscans"), "temp-udp.txt"))
		if os.path.isfile(os.path.join(os.path.join(FULLPATH,"unicornscans"), "temp-udp.txt")) and os.path.getsize(os.path.join(os.path.join(FULLPATH,"unicornscans"), "temp-udp.txt")) > 0:
			for udp_ports in udp_port_file:
				if udp_ports:
					print "   [+] Identified UDP: {0}".format(udp_ports)
				else:
					print "   [+] No UDP ports identified"
		
			print "   [+] Running UDP NMAP scans"
			cmd = "nmap -sU -sV -oA {0} -p {1} {2}".format(os.path.join(os.path.join(FULLPATH,"nmapscans"), options.target+"-udp"),udp_ports,options.target)
			warnings, resp = run_command(cmd)
			print_warnings(warnings)
	else:
		hosts_alive = file(os.path.join(FULLPATH, "hosts_alive.txt"))
		for target in hosts_alive:
			# TCP
			if options.ports == None:
				print "   [+] Scanning TCP ports: 1-65535"
				cmd = "unicornscan -msf -Iv {0} -p 1-65535 -l {1}".format(target, os.path.join(os.path.join(FULLPATH,"unicornscans"), target+"-tcp.txt"))
				warnings, resp = run_command(cmd)
				print_warnings(warnings)
			else:
				print "   [+] Scanning TCP ports: {0}".format(options.ports)
				cmd = "unicornscan -msf -Iv {0} -p {1} -l {2}".format(target, options.ports, os.path.join(os.path.join(FULLPATH,"unicornscans"), target+"-tcp.txt"))
				warnings, resp = run_command(cmd)
				print_warnings(warnings)
	
			cmd = "cat {0} | grep open | egrep -v '\[' | cut -d':' -f2 | cut -d' ' -f1 | tr '\n' ',' | rev | cut -b 2- | rev > {1}".format(os.path.join(os.path.join(FULLPATH,"unicornscans"), options.target+"-tcp.txt"),os.path.join(os.path.join(FULLPATH,"unicornscans"), "temp-tcp.txt"))
			os.system(cmd)
			tcp_port_file = file(os.path.join(os.path.join(FULLPATH,"unicornscans"), "temp-tcp.txt"))
			if os.path.isfile(os.path.join(os.path.join(FULLPATH,"unicornscans"), "temp-tcp.txt")) and os.path.getsize(os.path.join(os.path.join(FULLPATH,"unicornscans"), "temp-tcp.txt")) > 0:
				for tcp_ports in tcp_port_file:
					if tcp_ports:
						print "   [+] Identified TCP: {0}".format(tcp_ports)
					else:
						print "   [+] No TCP ports identified"
			
				print "   [+] Running TCP NMAP scans"
				cmd = "nmap -sS -sV -oA {0} -p {1} {2}".format(os.path.join(os.path.join(FULLPATH,"nmapscans"), target+"-tcp"),tcp_ports,target)
				warnings, resp = run_command(cmd)
				print_warnings(warnings)
	
			# UDP
			if options.ports == None:
				print "   [+] Scanning UDP ports: 1-65535"
				cmd = "unicornscan -mU -Iv {0} -p 1-65535 -l {1}".format(options.target, os.path.join(os.path.join(FULLPATH,"unicornscans"), options.target+"-udp.txt"))
				warnings, resp = run_command(cmd)
				print_warnings(warnings)
			else:		
				print "   [+] Scanning UDP ports: {0}".format(options.ports)
				cmd = "unicornscan -mU -Iv {0} -p {1} -l {2}".format(options.target, options.ports, os.path.join(os.path.join(FULLPATH,"unicornscans"), options.target+"-udp.txt"))
				warnings, resp = run_command(cmd)
				print_warnings(warnings)
	
			cmd = "cat {0} | grep open | egrep -v '\[' | cut -d':' -f2 | cut -d' ' -f1 | tr '\n' ',' | rev | cut -b 2- | rev > {1}".format(os.path.join(os.path.join(FULLPATH,"unicornscans"), options.target+"-udp.txt"), os.path.join(os.path.join(FULLPATH,"unicornscans"), "temp-udp.txt"))
			os.system(cmd)
			udp_port_file = file(os.path.join(os.path.join(FULLPATH,"unicornscans"), "temp-udp.txt"))
			if os.path.isfile(os.path.join(os.path.join(FULLPATH,"unicornscans"), "temp-udp.txt")) and os.path.getsize(os.path.join(os.path.join(FULLPATH,"unicornscans"), "temp-udp.txt")) > 0:
				for udp_ports in udp_port_file:
					if udp_ports:
						print "   [+] Identified UDP: {0}".format(udp_ports)
					else:
						print "   [+] No UDP ports identified"
			
				print "   [+] Running UDP NMAP scans"
				cmd = "nmap -sU -sV -oA {0} -p {1} {2}".format(os.path.join(os.path.join(FULLPATH,"nmapscans"), options.target+"-udp"),udp_ports,options.target)
				warnings, resp = run_command(cmd)
			print_warnings(warnings)
		
	print bold(" [*] Unicorn and NMAP scans complete")
	
	return

def highvalue(options, FULLPATH):
    return

def parseargs():
	usage="Usage: %prog [options]"
	epilog = """
	Examples:
	
	./ptf.py -t 192.168.24.100
	./ptf.py -s 192.168.2.10 -t 192.168.24.100-254
	./ptf.py -T targets.txt
	./ptf.py -T targets.txt -e x.x.x.x
	./ptf.py -u
	
	"""
	
	class MyOptParser(optparse.OptionParser):
	    def format_epilog(self, formatter):
	        return self.epilog
	        
	parser = MyOptParser(usage=usage, epilog=epilog)
	
	parser.add_option("-c", "--cleanup",
	    action="store_true",
	    dest="cleanup",
	    default=False,
	    help="If client and target already exist, remove old folder and files")
	parser.add_option("-s", "--sourceip",
	    action="store",
	    dest="sourceip",
	    default=False,
	    help="Execute enumeration from this source IP address")
	parser.add_option("-n", "--scanname",
	    action="store",
	    dest="scanname",
	    type="string",
	    default="ptf-scan",
	    help="The name of the scan, or client, that you are pen-testing. [Default: %default]")
	parser.add_option("-p", "--path",
	    action="store",
	    dest="path",
	    type="string",
	    default=os.path.join(USERHOME, "assessments"),
	    help="The base path for store output and scan results. [Default: %default]")
	parser.add_option("-u", "--update",
	    action="store_true",
	    dest="update",
	    default=False,
	    help="Update PTF, ExploitDB, Metasploit and any other tools used by this framework.")
	parser.add_option("-t", "--target",
	    action="store",
	    dest="target",
	    type="string",
	    default=False,
	    help="Target for discovery and enumeration scans. To scan multiple hosts use the -T option which allows for use of an input file for multiple hosts.")
	parser.add_option("-T", "--targetfile",
	    action="store",
	    dest="targetfile",
	    type="string",
	    default=False,
	    help="Input file containing a list of multiple hosts to discover and enumerate.")
	parser.add_option("-P", "--ports",
	    action="store",
	    dest="ports",
	    type="string",
	    help="Comma-separated list of ports to scan. E.g. -P 21,22,25")
	parser.add_option("-e", "--exclude",
	    action="store",
	    dest="exclude",
	    type="string",
	    default=False,
	    help="Exclude an IP address for all discovery and enumeration scans.")
	parser.add_option("-E", "--excludefile",
	    action="store",
	    dest="excludefile",
	    type="string",
	    default=False,
	    help="Input file containing a list of multiple hosts to exclude from discovery and enumeration scans.")
	parser.add_option("-A", "--automate",
	    action="append",
	    dest="automated_scans",
	    help="This flag allows you to automate some, or all, of the functions in this framework to replace the menu based system - e.g. automate host discovery and enumeration: -A discover -A enumerate. Use of this will prevent the menu from appearing and will only execute the automated function entered. I.e. enter all functions desired as you cannot mix and match automation and the menu system.                                                                             ** Available options are: discover, dns, enumeration, highvalue")
	    
	(options, args) = parser.parse_args()
	
	if len(args) != 0:
		parser.error("Wrong number of arguments")
		parser.print_help()
		sys.exit()
	
	return options

def main():
	options = parseargs();
	
	if options.update == True:
		runupdate()

	if options.sourceip == False:
		print "\n\033[1;31m Error: You have not configured a source IP address\033[1;m\n"
		parser.print_help()
		sys.exit()

	if options.target == False and options.targetfile == False:
		print "\n\033[1;31m Error: You have not selected a target\033[1;m\n"
		parser.print_help()
		sys.exit()
	#elif (options.target != False and options.targetfile == False) or (options.target == False and options.targetFile != False):
	else:
		# We're okay. User has input a target, or target input file
		if options.target == False:
			TARGET = options.targetfile
		else:
			TARGET = options.target

		FULLPATH=os.path.join(options.path,options.scanname)
		if not os.path.exists(FULLPATH):
			os.makedirs(FULLPATH)

		banner()
		checkversion()
		printconfig(options.sourceip, TARGET, options.path+"/"+options.scanname)
		print ""+LINE

		if options.cleanup == True:
			if len(options.scanname) >= 1:
				if os.path.exists(options.path+"/"+options.scanname):
					status = cleanup(options.path, options.scanname)				
				else:
					print red(" Error: Cannot cleanup. The scan name "+options.scanname+" cannot be found. Path used: "+options.path+"/"+options.scanname)

		#
		# Display the menu, or automate functionality?
		#
		
		# Display menu
		if options.automated_scans == None:
			answer = True
			while answer:
				print (""" 1. Host discovery
 2. DNS transfer & attacks
 3. Port & service enumeration
 4. Identify possible attack vectors

 0. Quit
				"""
				)
				try:
					answer = int(raw_input(" What would you like to do now? "))
	
					if answer == 1:
						hostdiscover(options, FULLPATH)
					elif answer == 2:
						dnsdiscover(options, FULLPATH)
					elif answer == 3:
						serviceenumeration(options, FULLPATH)
					elif answer == 4:
						highvalue()
					elif answer == 0:
						exit()
						
				except ValueError:
					print "\nNot a valid menu item"
					continue
	
				if not answer in range(0,4):
					print "\Not a valid menu item"
					continue
				
		# Automate functionality
		else:
			if "discover" in options.automated_scans:
				hostdiscover(options, FULLPATH)

			if "dns" in options.automated_scans:
				dnsdiscover(options, FULLPATH)

			if "enumeration" in options.automated_scans:
				serviceenumeration(options, FULLPATH)

			if "highvalue" in options.automated_scans:
				highvalue(options, FULLPATH)

if __name__ == '__main__':
    main()

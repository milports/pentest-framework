#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Name:       File comparison utility
# Author:     Nathan Bird
# Website:    https://github.com/milbot/pentest-framework
# Date:       23 July 2014
# Licence:    GNU GENERAL PUBLIC LICENSE v2
#

import sys, os, datetime, difflib, subprocess, optparse, apt, nmap
from os.path import expanduser

VERSION = "1.0"
USERHOME = expanduser("~")
PROG="ptf.py"
LINE=" ---------------------------------------------------------------------------------------\n"

def banner():
    print
    print ""+LINE
    print "\033[1;31m  ___            _____       _   _             ___                                  _   "
    print " | _ \___ _ _   |_   _|__ __| |_(_)_ _  __ _  | __| _ __ _ _ __  _____ __ _____ _ _| |__"
    print " |  _/ -_) ' \    | |/ -_|_-<  _| | ' \/ _` | | _| '_/ _` | '  \/ -_) V  V / _ \ '_| / /"
    print " |_| \___|_||_|   |_|\___/__/\__|_|_||_\__, | |_||_| \__,_|_|_|_\___|\_/\_/\___/_| |_\_\\"
    print "                                       |___/                                            \033[1;m"
    print
    print "\033[1;30m Author: Nathan Bird (milbot)"
    print " Version: "+VERSION+"\033[1;m\n"

def checkversion():
    commits_behind = subprocess.check_output("git rev-list HEAD...origin/master --count", shell=True)
    if commits_behind != 0:
        print " You are behind the master version.\n Please update to ensure you are running the latest version of this framework.\n Update by using the -u flag when running "+PROG+".\n\n E.g. ./ptf.py [options] -u target\n"

def cleanup(path, scanname):
    # Run cleanup is selected by user
    print " Cleaning up previously scan results ("+path+"/"+scanname+")....\n"
    subprocess.Popen("rm -rf "+path+"/"+scanname, shell=True)

def runupdate():
    print "\nUpdating ExploitDB...."
    subprocess.Popen("apt-get install exploitdb -y", shell=True)
    print "\nUpdate complete. Please re-run the framework to use the latest version.\n"
    exit()

def main():
    usage="Usage: %prog [options]"
    epilog = """
    Examples:

        ./ptf.py -t 192.168.24.100
        ./ptf.py -s 192.168.2.10 -t 192.168.24.100-254
        ./ptf.py -T targets.txt
        ./ptf.py -T targets.txt -e x.x.x.x
        ./ptf.py -u

    """

    class MyOptParser(optparse.OptionParser):
        """Override default epilog formatter, which strips newlines."""
        def format_epilog(self, formatter):
            return self.epilog

    parser = MyOptParser(usage=usage, epilog=epilog)

    parser.add_option("-c", "--cleanup",
        action="store_true",
        dest="cleanup",
        default=False,
        help="If client and target already exist, remove old folder and files")
    parser.add_option("-s", "--sourceip",
        action="store",
        dest="sourceip",
        default=False,
        help="Execute enumeration from this source IP address")
    parser.add_option("-n", "--scanname",
        action="store",
        dest="scanname",
        type="string",
        default="ptf-scan",
        help="The name of the scan, or client, that you are pen-testing. [Default: %default]")
    parser.add_option("-p", "--path",
        action="store",
        dest="path",
        type="string",
        default=USERHOME,
        help="The base path for store output and scan results. [Default: %default]")
    parser.add_option("-u", "--update",
        action="store_true",
        dest="update",
        default=False,
        help="Update PTF, ExploitDB, Metasploit and any other tools used by this framework.")
    parser.add_option("-t", "--target",
        action="store",
        dest="target",
        type="string",
        default=False,
        help="Target for discovery and enumeration scans. Must be in the format x.x.x.x, or x.x.x.y-x for a range of hosts. To scan multiple hosts use the -T option which allows for use of an input file for multiple hosts.")
    parser.add_option("-T", "--targetfile",
        action="store",
        dest="targetfile",
        type="string",
        default=False,
        help="Input file containing a list of multiple hosts to discover and enumerate.")
    parser.add_option("-e", "--exclude",
        action="store",
        dest="exclude",
        type="string",
        default=False,
        help="Exclude an IP address for all discovery and enumeration scans.")
    parser.add_option("-E", "--excludefile",
        action="store",
        dest="excludefile",
        type="string",
        default=False,
        help="Input file containing a list of multiple hosts to exclude from discovery and enumeration scans.")
    parser.add_option("-S", "--scantype",
        action="append",
        dest="scantype",
        type="string",
        default="all",
        help="Type of scan to execute, available options: discover, enumerate. [Default: %default]")

    (options, args) = parser.parse_args()

    if options.update == True:
        runupdate()

    if len(args) != 0:
        parser.error("Wrong number of arguments")
        parser.print_help()

    if options.target == False and options.targetfile == False:
        print "\n\033[1;31m Error: You have not selected a target\033[1;m\n"
        parser.print_help()
        exit()
    elif (options.target != False and options.targetfile == False) or (options.target == False and options.targetFile != False):
        # We're okay. User has input a target, or target input file
        banner()
        checkversion()
        print ""+LINE

        if options.cleanup == True:
            if len(options.scanname) >= 1:
                if os.path.exists(options.path+"/"+options.scanname):
                    cleanup(options.path, options.scanname)
                else:
                    print "\033[1;31m Error: Cannot cleanup. The scan name "+options.scanname+" cannot be found. Path used: "+options.path+"/"+options.scanname+"\033[1;m\n"

        # Start discovery

if __name__ == '__main__':
    main()
